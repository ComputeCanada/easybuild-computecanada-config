#!/usr/bin/env python

import argparse
import os
import re
import stat
import subprocess
import sys
import tempfile
from pathlib import Path
from elftools.common.exceptions import ELFError
from elftools.elf.dynamic import DynamicSection
from elftools.elf.elffile import ELFFile

REX_OS_INTERPRETER = "/lib64/ld-linux-x86-64.so.2.*"
REX_LINUX_INTERPRETER = ".*ld-linux-x86-64.so.2"
REX_LSB_INTERPRETER = ".*ld-lsb-x86-64.so.3"

def patch_rpath(filename, args, interpreter):

    set_interp = False
    has_needed = False
    interp_name = ""
    with open(filename, "rb") as f:
        try:
            elf = ELFFile(f)
            if elf.header['e_type'] not in {'ET_DYN', 'ET_EXEC'}:
                return
            for seg in elf.iter_segments('PT_INTERP'):
                interp_name = seg.get_interp_name()
            # check if shared libraries have NEEDED entries, if not
            # we whould not manipulate RPATH
            if not interp_name and (args.add_origin or args.add_path):
                for section in elf.iter_sections():
                    if isinstance(section, DynamicSection):
                        for tag in section.iter_tags():
                            if tag.entry.d_tag == 'DT_NEEDED':
                                has_needed = True
                                break
        except ELFError:
            return

    if interp_name:
        if (re.match(REX_OS_INTERPRETER, interp_name) or
            (args.any_interpreter and (re.match(REX_LINUX_INTERPRETER, interp_name) or
                                       re.match(REX_LSB_INTERPRETER, interp_name)))):
            subprocess.run(["patchelf", "--set-interpreter", interpreter, filename])
            set_interp = True

    if (args.add_origin or args.add_path) and (set_interp or has_needed):
        rpath = subprocess.check_output(["patchelf", "--print-rpath", filename])
        rpath_old = rpath

        if args.add_origin and not rpath.startswith(b"$ORIGIN"):
            if rpath.strip():
                rpath = b'$ORIGIN:' + rpath
            else:
                rpath = b'$ORIGIN'

        if args.add_path:
            if rpath:
                rpath = args.add_path + b":" + rpath
            else:
                rpath = args.add_path

        if rpath != rpath_old:
            subprocess.run(["patchelf", "--force-rpath", "--set-rpath", rpath, filename])


def patch_zip(filename, args, interpreter):
    fullname = os.path.realpath(filename)
    oldcwd = os.getcwd()
    with tempfile.TemporaryDirectory() as tmp:
        os.chdir(tmp)

        # Extract all and patch every binary file, and update the archive
        subprocess.run(["unzip", "-q", fullname])    
        for root, dirs, files in os.walk(os.getcwd()):
            root = Path(root)
            for name in files:
                fname = root / name
                oldperm = os.stat(fname).st_mode
                os.chmod(fname, oldperm | stat.S_IWUSR)
                patch_rpath(fname, args, interpreter)
                os.chmod(fname, oldperm)

        subprocess.run(["zip", "-rq", fullname, "."])
        os.chdir(oldcwd)
        print(oldcwd)


def main():
    parser = argparse.ArgumentParser(
        description='Links Linux binaries to libraries in the current Gentoo Prefix')
    parser.add_argument('-p', '--path', type=str, required=True, help="Path to recursively descend",
                        metavar='<path to search>')
    parser.add_argument('--add_origin', action='store_true', help="Add $ORIGIN to RPATH")
    parser.add_argument('--add_path', type=str, help="RPATH to add",
                        metavar='<path>')
    parser.add_argument('--any_interpreter', action='store_true',
                        help="Patch any interpreter, not only the system one")
    args = parser.parse_args()

    # Avoid failing to set rpaths when a symlink is provided
    if stat.S_ISLNK(os.stat(args.path).st_mode):
        print(f"error: {args.path} is a symlink. Please provide a path not a symlink.")
        return 1

    if "EPREFIX" in os.environ:
        prefix = Path(os.environ["EPREFIX"])
        year = int(os.environ["EBVERSIONGENTOO"])
        if year >= 2023:
            interpreter = prefix / "lib64" / "ld-linux-x86-64.so.2"
        else:
            interpreter = prefix / "lib" / "ld-linux-x86-64.so.2"
    else:
        print("Neither nixpkgs nor gentoo modules are loaded. Aborting")
        sys.exit(1)

    for root, dirs, files in os.walk(args.path):
        root = Path(root)
        for name in files:
            f = root / name
            if name[-4:] in {".whl", ".jar"}:
                patch_zip(f, args, interpreter)
            else:
                patch_rpath(f, args, interpreter)
    return 0

if __name__ == "__main__":
    sys.exit(main())
