#!/usr/bin/env python

import argparse
import os
import re
import stat
import subprocess
import sys
import tempfile
from pathlib import Path
from elftools.common.exceptions import ELFError
from elftools.elf.dynamic import DynamicSection
from elftools.elf.elffile import ELFFile

REX_OS_INTERPRETER = "/lib64/ld-linux-x86-64.so.2.*"
REX_LINUX_INTERPRETER = ".*ld-linux-x86-64.so.2"
REX_LSB_INTERPRETER = ".*ld-lsb-x86-64.so.3"

def patch_rpath(filename, args, interpreter):

    set_interp = False
    has_needed = False
    interp_name = ""
    try:
        with open(filename, "rb") as f:
            try:
                elf = ELFFile(f)
                if elf.header['e_type'] not in {'ET_DYN', 'ET_EXEC'}:
                    return
                for seg in elf.iter_segments():
                    if hasattr(seg, 'get_interp_name'):
                        interp_name = seg.get_interp_name()
                        break
                # check if shared libraries have NEEDED entries, if not
                # we whould not manipulate RPATH
                if not interp_name and (args.add_origin or args.add_path):
                    for section in elf.iter_sections():
                        if isinstance(section, DynamicSection):
                            for tag in section.iter_tags():
                                if tag.entry.d_tag == 'DT_NEEDED':
                                    has_needed = True
                                    break
            except ELFError:
                return
    except FileNotFoundError:
        return

    if interp_name:
        if (re.match(REX_OS_INTERPRETER, interp_name) or
            (args.any_interpreter and (re.match(REX_LINUX_INTERPRETER, interp_name) or
                                       re.match(REX_LSB_INTERPRETER, interp_name)))):
            subprocess.run(["patchelf", "--set-interpreter", interpreter, filename])
            set_interp = True

    if (args.add_origin or args.add_path) and (set_interp or has_needed):
        rpath = subprocess.check_output(["patchelf", "--print-rpath", filename])
        rpath_old = rpath

        if args.add_origin and not rpath.startswith(b"$ORIGIN"):
            if rpath.strip():
                rpath = b'$ORIGIN:' + rpath
            else:
                rpath = b'$ORIGIN'

        if args.add_path:
            if rpath:
                rpath = args.add_path + b":" + rpath
            else:
                rpath = args.add_path

        if rpath != rpath_old:
            subprocess.run(["patchelf", "--force-rpath", "--set-rpath", rpath, filename])


def patch_zip(filename, args, interpreter):
    fullname = os.path.realpath(filename)
    oldcwd = os.getcwd()
    with tempfile.TemporaryDirectory() as tmp:
        os.chdir(tmp)

        # Extract all and patch every binary file, and update the archive
        subprocess.run(["unzip", "-q", fullname])    
        for root, dirs, files in os.walk(os.getcwd()):
            root = Path(root)
            for name in files:
                fname = root / name
                oldperm = os.stat(fname).st_mode
                os.chmod(fname, oldperm | stat.S_IWUSR)
                patch_rpath(fname, args, interpreter)
                os.chmod(fname, oldperm)

        subprocess.run(["zip", "-rq", fullname, "."])
        os.chdir(oldcwd)
        print(oldcwd)

def patch_file(filename, args, interpreter):
    if str(filename)[-4:] in {".whl", ".jar"}:
        patch_zip(filename, args, interpreter)
    else:
        patch_rpath(filename, args, interpreter)

def main():
    parser = argparse.ArgumentParser(
        description='Links Linux binaries to libraries in the current Gentoo Prefix')
    parser.add_argument('-p', '--path', required=True, help="Files or paths to recursively descend",
                        nargs='+', metavar='<path to search>')
    parser.add_argument('--add_origin', action='store_true', help="Add $ORIGIN to RPATH")
    parser.add_argument('--add_path', help="RPATH(s) to add", nargs='+',
                        metavar='<path>')
    parser.add_argument('--any_interpreter', action='store_true',
                        help="Patch any interpreter, not only the system one")
    args = parser.parse_args()
    if args.add_path:
        args.add_path = os.pathsep.join(args.add_path)

    # Avoid failing to set rpaths when a symlink is provided
    for path in args.path:
        if stat.S_ISLNK(os.stat(path).st_mode):
            print(f"error: {args.path} is a symlink. Please provide files or paths, not a symlink.")
            return 1

    if "EPREFIX" in os.environ:
        prefix = Path(os.environ["EPREFIX"])
        year = int(os.environ["EBVERSIONGENTOO"])
        if year >= 2023:
            interpreter = prefix / "lib64" / "ld-linux-x86-64.so.2"
        else:
            interpreter = prefix / "lib" / "ld-linux-x86-64.so.2"
    else:
        print("Neither nixpkgs nor gentoo modules are loaded. Aborting")
        sys.exit(1)

    for path in args.path:
        if stat.S_ISDIR(os.stat(path).st_mode):
            for root, dirs, files in os.walk(path):
                root = Path(root)
                for name in files:
                    patch_file(root / name, args, interpreter)
        else:
            patch_file(path, args, interpreter)
    return 0

if __name__ == "__main__":
    sys.exit(main())
